# ========================================================================== #
#                                                                            #
#    pi-builder - extensible tool to build Arch Linux ARM for Raspberry Pi   #
#                 on x86_64 host using Docker.                               #
#                                                                            #
#    Copyright (C) 2018-2023  Maxim Devaev <mdevaev@gmail.com>               #
#                                                                            #
#    This program is free software: you can redistribute it and/or modify    #
#    it under the terms of the GNU General Public License as published by    #
#    the Free Software Foundation, either version 3 of the License, or       #
#    (at your option) any later version.                                     #
#                                                                            #
#    This program is distributed in the hope that it will be useful,         #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of          #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           #
#    GNU General Public License for more details.                            #
#                                                                            #
#    You should have received a copy of the GNU General Public License       #
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.  #
#                                                                            #
# ========================================================================== #

# Library of common functions
include lib.mk

# (Optional) Configuration file
-include config.mk

# System command shortcuts for sudo and Docker
export SUDO ?= sudo
export DOCKER ?= docker
export DOCKER_RUN_TTY ?= $(DOCKER) run --rm --tty
export DOCKER_RUN_INT ?= $(DOCKER) run --rm --interactive
export DOCKER_RUN ?= $(DOCKER) run --rm

export NC ?=

# Temporary images namespace, call in whatever you like
PROJECT ?= common

# =====
# Target hardware platform information
# =====
# Raspberry Pi hardware platform
BOARD ?= rpi4
export BOARD= rpi4
# ARM architecture
ARCH ?= arm
export ARCH ?= arm

# =====
# Target OS configuration information
# =====
# Raspberry Pi OS (archlinuxarm or rpios)
OS ?= archlinuxarm
# Target system hostname
HOSTNAME ?= pi
# Target system locale (UTF-8)
LOCALE ?= en_US
# Target system timezone
TIMEZONE ?= America/New_York

# =====
# Target OS build information
# =====
# List of operating system stages to build
# STAGES ?= __init__ os pikvm-repo watchdog no-bluetooth no-audit ro ssh-keygen __cleanup__
STAGES ?= __init__ os no-bluetooth no-audit ro ssh-keygen __cleanup__
# Combination of the operating system, board, and architecture used to specify the target platform for building the project
_OS_BOARD_ARCH = $(OS)-$(BOARD)-$(ARCH)
# Name for Docker image generated by pi-builder; includes the project name and the operating system board architecture
_DOCKER_IMAGE_NAME = pi-builder.$(PROJECT).$(_OS_BOARD_ARCH)
# Directory for caching build artifacts
_CACHE_DIR = .cache

# Directory for storing build files
_BUILD_DIR = .build

# Configuration file for the built image
_BUILT_IMAGE_CONFIG = .built.conf

# Root filesystem result path
_RESULT_ROOTFS = $(_CACHE_DIR)/$(PROJECT).$(_OS_BOARD_ARCH).rootfs

# Image result path
_RESULT_IMAGE = $(_IMAGE_DIR)/$(PROJECT).$(_OS_BOARD_ARCH).img

# Options for mounting cache volume
_CACHE_VOLUME_OPTS_SAVE = \
	--volume=$(_TOOLBOX_VOLUME):/$(_CACHE_DIR)
_CACHE_VOLUME_OPTS_INSTALL = \
	--volume=$(_TOOLBOX_VOLUME):/root/$(_CACHE_DIR) \
	--workdir=/root/$(_CACHE_DIR)/..

_BASE_VOLUME_OPTS = \
	--volume=$(_TOOLBOX_VOLUME):/root/$(_CACHE_DIR) \
	--volume=$(shell pwd)/base:/root/base \
	--workdir=/root/base/..

# =====
# OS repository information
# =====
# Arch Linux ARM repository URL
export ARCH_DIST_REPO_URL ?= http://os.archlinuxarm.org
# Raspberry Pi OS repository URL
export RPIOS_IMAGES_URL ?= https://downloads.raspberrypi.com
# PiKVM repository URL
ARCH_PIKVM_REPO_URL ?= https://files.pikvm.org/repos/arch/
ARCH_PIKVM_REPO_KEY ?= 912C773ABBD1B584

# =====
# Target image information
# =====
# Memory card location
CARD ?= /dev/mmcblk0
# Disk configuration file
DISK ?= ./disk/$(OS).conf
# Image file
IMAGE ?= ./$(PROJECT).$(OS)-$(BOARD)-$(ARCH).img
# Compressed image file
IMAGE_XZ ?=
# Final images directory
_IMAGE_DIR = images


BUILD_OPTS ?=

# =====
# Toolbox image information
# =====
# Specifies the Docker image for the pi-builder toolbox
export _TOOLBOX_IMAGE = jmcombs/pi-builder-toolbox
# Specifies the Docker volume for the pi-builder toolbox
export _TOOLBOX_VOLUME = pi-builder-toolbox-volume
# Ensures the pi-builder toolbox image is ready
__DEP_TOOLBOX := $(if $(call optbool,$(PASS_ENSURE_TOOLBOX)),,toolbox)

# =====
# Function to read a specific configuration value from the built image config file
define read_built_config
$(shell grep "^$(1)=" $(_BUILT_IMAGE_CONFIG) | cut -d"=" -f2)
endef

# Function to display the current running configuration
define show_running_config
$(call say,"Running configuration")
@ echo "    PROJECT    = $(PROJECT)"
@ echo "    OS         = $(OS)"
@ echo "    BOARD      = $(BOARD)"
@ echo "    ARCH       = $(ARCH)"
@ echo "    STAGES     = $(STAGES)"
@ echo "    BUILD_OPTS = $(BUILD_OPTS)"
@ echo
@ echo "    HOSTNAME   = $(HOSTNAME)"
@ echo "    LOCALE     = $(LOCALE)"
@ echo "    TIMEZONE   = $(TIMEZONE)"
@ echo
@ echo "    CARD       = $(CARD)"
@ echo "    IMAGE      = $(IMAGE)"
@ echo "    IMAGE_XZ   = $(IMAGE_XZ)"
endef

# Function to check if the build has been completed
define check_build
$(if $(wildcard $(_BUILT_IMAGE_CONFIG)),,$(call die,"Not built yet"))
endef

# =====
# Default target
all:
	@ echo
	$(call say,"Available commands")
	@ echo "    make                     # Print this help"
	@ echo "    make rpi2|rpi3|rpi4|zero2w  # Build Arch-ARM rootfs with pre-defined config"
	@ echo "    make shell               # Run Arch-ARM shell"
	@ echo "    make toolbox             # Build the toolbox image"
	@ echo "    make scan                # Find all RPi devices in the local network"
	@ echo "    make clean               # Remove the generated rootfs"
	@ echo "    make image               # Make image file $(IMAGE)"
	@ echo "    make install             # Format $(CARD) and flash the filesystem"
	@ echo
	$(call show_running_config)
	@ echo


# Set the BOARD variable based on the target
rpi2: BOARD=rpi2
rpi3: BOARD=rpi3
rpi4: BOARD=rpi4
zero2w: BOARD=zero2w

# Get the current uid and gid
UID := $(shell id -u)
GID := $(shell id -g)

# Target to build Arch-ARM rootfs with pre-defined config
rpi2 rpi3 rpi4 zero2w: os


# Target to run the built image
run: 
	$(call check_build)
	$(DOCKER_RUN_TTY) \
			$(if $(RUN_CMD),$(RUN_OPTS),--interactive) \
			--hostname=$(call read_built_config,HOSTNAME) \
		$(call read_built_config,IMAGE) \
			$(if $(RUN_CMD),$(RUN_CMD),/bin/bash)


# Target to run the Arch-ARM shell
shell: override RUN_OPTS:="$(RUN_OPTS) -i"
shell: run


# Target to pull toolbox image
toolbox: 
	$(call say,"Ensuring toolbox image")
	$(DOCKER) run \
			--rm \
			$(if $(call optbool,$(NC)),--no-cache,) \
			$(_TOOLBOX_IMAGE)
	$(DOCKER) volume create --name=$(_TOOLBOX_VOLUME)
	$(call say,"Toolbox image is ready")


# Target to find all RPi devices in the local network
scan: $(__DEP_TOOLBOX)
	$(call say,"Searching for Pis in the local network")
	$(DOCKER_RUN_TTY) \
			--net=host \
		$(_TOOLBOX_IMAGE) \
			arp-scan --localnet | grep -Pi "\s(b8:27:eb:|dc:a6:32:)" || true


# =====
# Target to build the OS
os: _buildctx
	$(call say,"Building OS")
	cd $(_BUILD_DIR) && $(DOCKER) buildx build \
			--rm \
			--platform=linux/$(ARCH) \
			--tag=$(_DOCKER_IMAGE_NAME) \
			--load \
			$(if $(call optbool,$(NC)),--no-cache,) \
			--build-arg "BOARD=$(BOARD)" \
			--build-arg "ARCH=$(ARCH)" \
			--build-arg "LOCALE=$(LOCALE)" \
			--build-arg "TIMEZONE=$(TIMEZONE)" \
			--build-arg "ARCH_DIST_REPO_URL=$(ARCH_DIST_REPO_URL)" \
			--build-arg "ARCH_PIKVM_REPO_URL=$(ARCH_PIKVM_REPO_URL)" \
			--build-arg "ARCH_PIKVM_REPO_KEY=$(ARCH_PIKVM_REPO_KEY)" \
			--build-arg "REBUILD=$(shell uuidgen)" \
			$(BUILD_OPTS) \
		.
	echo "IMAGE=$(_DOCKER_IMAGE_NAME)" > $(_BUILT_IMAGE_CONFIG)
	echo "HOSTNAME=$(HOSTNAME)" >> $(_BUILT_IMAGE_CONFIG)
	$(call show_running_config)
	$(call say,"Build complete")


# Target to assemble the main Dockerfile
_buildctx: | clean base
	$(eval _init = $(_BUILD_DIR)/stages/__init__/Dockerfile.part)
	$(call say,"Assembling main Dockerfile")
	#
	mkdir -p $(_BUILD_DIR)
	ln base/$(_OS_BOARD_ARCH).tgz $(_BUILD_DIR)
	#
	cp -a stages/common $(_BUILD_DIR)/stages
	cp -a stages/$(OS)/* $(_BUILD_DIR)/stages
	sed -i -e 's|%ADD_BASE_ROOTFS_TGZ%|ADD $(_OS_BOARD_ARCH).tgz /|g' $(_init)
	for var in BOARD ARCH LOCALE TIMEZONE ARCH_DIST_REPO_URL ARCH_PIKVM_REPO_URL ARCH_PIKVM_REPO_KEY; do \
		echo "ARG $$var" >> $(_init) \
		&& echo "ENV $$var \$$$$var" >> $(_init) \
	; done
	#
	echo > $(_BUILD_DIR)/Dockerfile
	for stage in $(STAGES); do \
		cat $(_BUILD_DIR)/stages/$$stage/Dockerfile.part >> $(_BUILD_DIR)/Dockerfile \
	; done
	#
	$(call cachetag,$(_BUILD_DIR))
	$(call say,"Main Dockerfile is ready")


# Target to ensure the base rootfs
base: $(__DEP_TOOLBOX)
	$(call say,"Ensuring base rootfs")
	$(DOCKER_RUN_TTY) \
			--privileged \
			$(_BASE_VOLUME_OPTS) \
		$(_TOOLBOX_IMAGE) \
			/tools/download-image.py \
				--os=$(OS) \
				--os-repo-url=$(if $(filter archlinuxarm,$(OS)),$(ARCH_DIST_REPO_URL),$(RPIOS_IMAGES_URL)) \
				--arch=$(ARCH) \
				--board=$(BOARD) \
				--output-dir=/root/base \
				--cache-dir=/root/$(_CACHE_DIR) \
				--uid=$(UID) \
				--gid=$(GID)
	$(call say,"Base rootfs is ready")


# Target to remove the generated rootfs
clean:
	$(call say,"Removing Build Cache and Images from Docker")
	rm -f $(_BUILT_IMAGE_CONFIG)
	rm -rf $(_BUILD_DIR)
	rm -f base/*.tgz *.tmp *.img *.xz
	$(DOCKER) volume rm $(_TOOLBOX_VOLUME) || true
	$(DOCKER) rmi $(_DOCKER_IMAGE_NAME) || true
	$(call say,"Cleanup complete")

# Target to extract the image from Docker
extract: $(__DEP_TOOLBOX)
	$(call check_build)
	$(call say,"Extracting image from Docker")
	mkdir -p $(_IMAGE_DIR)
	$(call cachetag,$(_IMAGE_DIR))
	$(DOCKER_RUN) \
		$(_CACHE_VOLUME_OPTS_SAVE) \
		--volume=/var/run/docker.sock:/var/run/docker.sock docker:latest \
		sh -c "docker save $(call read_built_config,IMAGE) > /$(_RESULT_ROOTFS).tar"
	$(DOCKER_RUN_TTY) \
			$(_CACHE_VOLUME_OPTS_INSTALL) \
		$(_TOOLBOX_IMAGE) \
			/tools/docker-extract.py \
				--remove-root \
				--root=/root/$(_RESULT_ROOTFS) \
				--set-hostname="$(call read_built_config,HOSTNAME)" \
				--set-resolv-symlink=/run/systemd/resolve/resolv.conf \
			/root/$(_RESULT_ROOTFS).tar
	$(call say,"Extraction complete")


# Target to install the rootfs to the specified card
install: $(__DEP_TOOLBOX) extract
	$(call check_build)
	$(call say,"Installing to $(CARD)")
	cat $(DISK) | $(DOCKER_RUN_INT) \
			--privileged \
			$(_CACHE_VOLUME_OPTS_INSTALL) \
		$(_TOOLBOX_IMAGE) \
			/tools/install.py \
				--root=$(_RESULT_ROOTFS) \
				--card=$(CARD)
	$(call say,"Installation complete")


# Target to create the image file
image: $(__DEP_TOOLBOX) extract
	$(eval _suffix = $(if $(call optbool,$(IMAGE_XZ)),.xz,))
	$(call check_build)
	$(call say,"Creating image $(IMAGE)")
	$(call remove_image)
	cat $(DISK) | $(DOCKER_RUN_INT) \
			--volume=/dev:/root/dev \
			--privileged \
			--volume=$(shell pwd)/$(_IMAGE_DIR):/$(_IMAGE_DIR) \
			$(_CACHE_VOLUME_OPTS_INSTALL) \
		$(_TOOLBOX_IMAGE) \
			/tools/install.py \
				$(if $(call optbool,$(IMAGE_XZ)),--compress,) \
				--devfs-prefix=/root \
				--root=/root/$(_RESULT_ROOTFS) \
				--image=/$(_RESULT_IMAGE)
	$(call say,"Image complete")

# =====
.PHONY: toolbox base
.NOTPARALLEL:
